plugins {
    id "application"
    id "idea"
    id "org.asciidoctor.jvm.convert" version "3.3.2"
    id "nebula.ospackage" version "8.5.6"
}

java {
    modularity.inferModulePath = true
}
def mainClassName = "org.${project.name}.cli.Main"
application {
    mainModule.set("${project.name}")
    mainClass.set(mainClassName)
    applicationDefaultJvmArgs = [
            // the cli is short lived, so let's enable a fast JVM startup
            "-XX:TieredStopAtLevel=1"
    ]
}

processResources {
    filesMatching("**/application.properties") {
        expand(version: project.version)
    }
}
compileJava {
    options.release = 11
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}"]
}
test {
    useJUnitPlatform()
}
repositories {
    mavenCentral()
}

sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file("src/integration-test/java")
        }
        resources.srcDir file("src/integration-test/resources")
    }
}

project.idea.module {
    // Mark integration tests are test sources for Intellij IDEA
    sourceDirs -= project.sourceSets.integrationTest.java.srcDirs
    sourceDirs -= project.sourceSets.integrationTest.java.srcDirs
    testSourceDirs += project.sourceSets.integrationTest.java.srcDirs
    testSourceDirs += project.sourceSets.integrationTest.java.srcDirs
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

dependencies {
    def lombokVersion = "1.18.20"
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    integrationTestCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    integrationTestAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"

    def picocliVersion = "4.6.1"
    implementation "info.picocli:picocli:${picocliVersion}"
    annotationProcessor "info.picocli:picocli-codegen:${picocliVersion}"
    // testing
    def junitVersion = "5.5.2"
    testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
    testImplementation "org.assertj:assertj-core:3.14.0"
    def mockitoVersion = "3.6.28"
    testImplementation "org.mockito:mockito-core:${mockitoVersion}"
    testImplementation "org.mockito:mockito-junit-jupiter:${mockitoVersion}"

    integrationTestImplementation sourceSets.main.output
    integrationTestImplementation sourceSets.test.output
}

/**
 * This task is only needed for integrationTest to run
 * However, as it modifies the content of `build/libs`
 * Gradle requires to explicit the dependencies of tasks
 * relying on the `build/libs` as an input:
 * startScripts, distTar, distZip, installDist
 */
task copyDependencies(type: Copy) {
    from configurations.runtimeClasspath
    into "build/libs"
}
startScripts.dependsOn copyDependencies
distTar.dependsOn copyDependencies
distZip.dependsOn copyDependencies
installDist.dependsOn copyDependencies

task integrationTest(type: Test) {
    dependsOn copyDependencies, jar
    useJUnitPlatform()
    description = "Runs integration tests."
    group = "verification"

    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
}
check.dependsOn integrationTest

task buildNativePackage(type: Exec) {
    dependsOn installDist

    commandLine "jpackage",
            "--name",
            "${project.name}",
            "--app-version",
            "${project.version}",
            "--module-path",
            "${buildDir}/install/${project.name}/lib",
            "-m",
            "${project.name}/${mainClassName}",
            "--license-file",
            "LICENSE",
            "--dest",
            "${buildDir}"
}

task buildNativeImage(type: Exec) {
    dependsOn installDist
    inputs.dir("${buildDir}/install/${project.name}/lib")
    outputs.file("${buildDir}/bin/${project.name}")
    workingDir "${buildDir}/bin"

    commandLine nativeImageBin(),
            "--verbose",
            "--no-fallback",
            "-H:Name=${project.name}",
            "-H:-AddAllCharsets",
            "-H:-UseServiceLoaderFeature",
            "-J-Drx.unsafe-disable=true",
            "-H:+RemoveUnusedSymbols",
            "-DremoveUnusedAutoconfig=true",
            "--initialize-at-build-time",
            "-H:+PrintImageElementSizes",
            // Native image size debug flags
//            "-H:DashboardDump=img-dump",
//            "-H:+DashboardAll",
//            "-H:+DashboardHeap",
//            "-H:+DashboardCode",
//            "-H:+DashboardPointsTo",
//            "-H:+DashboardPretty",
            // Native image stdout debug
//            "-H:+PrintUniverse",
//            "-H:+PrintHeapHistogram",
//            "-H:+PrintAnalysisCallTree",
//            "-H:+PrintImageObjectTree",
//            "-H:+PrintHeapHistogram",
//            "-H:+PrintMethodHistogram",
//            "-H:+PrintImageHeapPartitionSizes",
            "-cp", "${buildDir}/install/${project.name}/lib/*",
            "${mainClassName}"
}

private static String nativeImageBin() {
    def env = System.env.GRAALVM_HOME ?: System.env.JAVA_HOME
    if (env != null) {
        return "${env}/bin/native-image"
    }
    return "native-image"
}

task generateManpageAsciiDoc(type: JavaExec) {
    dependsOn installDist
    inputs.dir("${buildDir}/install/${project.name}/")
    outputs.dir("${buildDir}/docs/manpage/adoc")
    classpath "${buildDir}/install/${project.name}/lib/*", configurations.annotationProcessor
    main "picocli.codegen.docgen.manpage.ManPageGenerator"
    args "org.${project.name}.cli.MainCommand",
            "--factory=org.${project.name}.cli.BeanFactory",
            "--outdir=${buildDir}/docs/manpage/adoc"
}

asciidoctor {
    dependsOn generateManpageAsciiDoc
    inputs.dir("${buildDir}/docs/manpage/adoc")
    outputs.dirs(
            "${buildDir}/docs/manpage/html5",
            "${buildDir}/docs/manpage/manpage"
    )
    sourceDir = file("${buildDir}/docs/manpage/adoc")
    outputDir = file("${buildDir}/docs/manpage/")
    logDocuments = true
    outputOptions {
        backends = ["manpage", "html5"]
    }
}

task generateManpage(type: Exec) {
    dependsOn asciidoctor
    inputs.dir("${buildDir}/docs/manpage/manpage")
    outputs.dir("${buildDir}/docs/manpage/gz")
    workingDir "${buildDir}/docs"
    commandLine "/bin/sh", "-c", "rm -rf manpage/gz && cp -R manpage/manpage manpage/gz && gzip -9 manpage/gz/*"
}

task generateShellCompletions(type: JavaExec) {
    dependsOn installDist
    inputs.dir("${buildDir}/install/${project.name}/")
    outputs.file("${buildDir}/shell/completions/${project.name}")
    classpath "${buildDir}/install/${project.name}/lib/*"
    main "picocli.AutoComplete"
    args "org.${project.name}.cli.MainCommand",
            "--factory=org.${project.name}.cli.BeanFactory",
            "--completionScript=${buildDir}/shell/completions/${project.name}"
    doFirst {
        file("${buildDir}/shell/completions/${project.name}").delete()
    }
}

ospackage {
    packageName = "symly"
    packageDescription = "Manages symbolic links."
    url = "https://github.com/loicrouchon/symly"

    release = '1'
    os = LINUX
    user = "root"

    license = "ASL 2.0"
    from("LICENSE") {
        into "usr/share/doc/${project.name}"
        rename "LICENSE", "copyright"
        fileType = LICENSE
    }

    from("${buildDir}/bin/${project.name}") {
        into "usr/bin/"
        fileMode 755
    }
    from("${buildDir}/docs/manpage/gz") {
        into "usr/man/man1"
        fileType = DOC
    }
// requires https://github.com/remkop/picocli/issues/1346
//    from("${buildDir}/shell/completions") {
//        into "/usr/share/bash-completion/completions"
//    }
}

task buildDebPackage(type: Deb) {
    dependsOn generateManpage, generateShellCompletions
    maintainer = "Loic Rouchon"
    arch = "amd64"
    license = "ASL 2.0"
}

task buildRpmPackage(type: Rpm) {
    dependsOn generateManpage, generateShellCompletions
    packager = "Lo√Øc Rouchon"
    arch = "x86_64"
    addParentDirs = false
}
